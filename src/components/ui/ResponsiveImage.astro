---
/**
 * Responsive Image Component for ClearLane Initiative
 * Optimized loading with multiple formats and sizes
 */

export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  sizes?: string;
  loading?: 'lazy' | 'eager';
  priority?: boolean;
  quality?: number;
  format?: 'webp' | 'avif' | 'jpeg' | 'png';
  class?: string;
  aspectRatio?: '16:9' | '4:3' | '1:1' | '3:2' | 'auto';
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  placeholder?: 'blur' | 'empty';
  caption?: string;
}

const {
  src,
  alt,
  width,
  height,
  sizes = "(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw",
  loading = 'lazy',
  priority = false,
  quality = 80,
  format = 'webp',
  class: className = '',
  aspectRatio = 'auto',
  objectFit = 'cover',
  placeholder = 'empty',
  caption
} = Astro.props;

// Generate responsive image URLs
const generateImageUrl = (src: string, width: number, format: string, quality: number) => {
  // In production, this would integrate with your image optimization service
  const params = new URLSearchParams({
    w: width.toString(),
    q: quality.toString(),
    f: format
  });
  return `${src}?${params.toString()}`;
};

const breakpoints = [320, 640, 768, 1024, 1280, 1536];
const webpSrcSet = breakpoints.map(bp => `${generateImageUrl(src, bp, 'webp', quality)} ${bp}w`).join(', ');
const fallbackSrcSet = breakpoints.map(bp => `${generateImageUrl(src, bp, 'jpeg', quality)} ${bp}w`).join(', ');

const aspectRatioClasses = {
  '16:9': 'aspect-video',
  '4:3': 'aspect-4/3',
  '1:1': 'aspect-square',
  '3:2': 'aspect-3/2',
  'auto': ''
};

const objectFitClasses = {
  cover: 'object-cover',
  contain: 'object-contain',
  fill: 'object-fill',
  none: 'object-none',
  'scale-down': 'object-scale-down'
};
---

<figure class={`relative ${aspectRatio !== 'auto' ? aspectRatioClasses[aspectRatio] : ''} ${className}`}>
  <!-- Placeholder for blur effect -->
  {placeholder === 'blur' && (
    <div class="absolute inset-0 bg-gradient-to-br from-gray-200 to-gray-300 animate-pulse" aria-hidden="true"></div>
  )}

  <!-- Main responsive picture element -->
  <picture class="block w-full h-full">
    <!-- WebP source -->
    <source
      srcset={webpSrcSet}
      sizes={sizes}
      type="image/webp"
    />

    <!-- Fallback JPEG source -->
    <source
      srcset={fallbackSrcSet}
      sizes={sizes}
      type="image/jpeg"
    />

    <!-- Main img element -->
    <img
      src={generateImageUrl(src, 800, 'jpeg', quality)}
      alt={alt}
      width={width}
      height={height}
      loading={priority ? 'eager' : loading}
      decoding="async"
      class={`w-full h-full ${objectFitClasses[objectFit]} transition-opacity duration-300 ${className}`}
      onload="this.style.opacity='1'"
      style="opacity: 0;"
    />
  </picture>

  <!-- Loading indicator -->
  <div class="absolute inset-0 flex items-center justify-center bg-gray-100 transition-opacity duration-300 loading-placeholder">
    <div class="flex items-center space-x-2 text-gray-500">
      <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24" fill="none">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      <span class="text-sm">Loading image...</span>
    </div>
  </div>

  <!-- Caption -->
  {caption && (
    <figcaption class="mt-2 text-sm text-gray-600 text-center">
      {caption}
    </figcaption>
  )}
</figure>

<style>
  /* Intersection Observer for lazy loading enhancement */
  img[loading="lazy"] {
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }

  img[loading="lazy"].loaded {
    opacity: 1;
  }

  /* Hide loading placeholder when image is loaded */
  figure:has(img.loaded) .loading-placeholder {
    opacity: 0;
    pointer-events: none;
  }

  /* Error state */
  img[data-error="true"] {
    opacity: 1;
    background: linear-gradient(45deg, #f3f4f6, #e5e7eb);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  img[data-error="true"]::before {
    content: "üñºÔ∏è Image unavailable";
    color: #6b7280;
    font-size: 0.875rem;
    text-align: center;
  }

  /* High contrast mode */
  @media (prefers-contrast: high) {
    .loading-placeholder {
      background-color: white;
      border: 2px solid black;
    }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    img,
    .loading-placeholder {
      transition: none;
    }

    .animate-spin {
      animation: none;
    }
  }

  /* Print styles */
  @media print {
    .loading-placeholder {
      display: none;
    }

    img {
      opacity: 1 !important;
      break-inside: avoid;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('img[loading="lazy"]');

    // Enhanced intersection observer for lazy loading
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target as HTMLImageElement;

          // Load image
          const tempImg = new Image();
          tempImg.onload = () => {
            img.classList.add('loaded');
            (img as HTMLElement).style.opacity = '1';
          };

          tempImg.onerror = () => {
            img.setAttribute('data-error', 'true');
            img.classList.add('loaded');
          };

          tempImg.src = img.src;
          if (img.srcset) tempImg.srcset = img.srcset;

          imageObserver.unobserve(img);
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.01
    });

    images.forEach(img => {
      imageObserver.observe(img);
    });

    // Handle image load events for eager loading
    const eagerImages = document.querySelectorAll('img[loading="eager"]');
    eagerImages.forEach(img => {
      img.addEventListener('load', () => {
        (img as HTMLElement).style.opacity = '1';
        img.classList.add('loaded');
      });

      img.addEventListener('error', () => {
        img.setAttribute('data-error', 'true');
        img.classList.add('loaded');
      });
    });

    // Performance monitoring
    if ('performance' in window) {
      const trackImagePerformance = (img: HTMLImageElement) => {
        const startTime = performance.now();

        const observer = new PerformanceObserver((list) => {
          list.getEntries().forEach((entry) => {
            if (entry.name.includes(img.src)) {
              const loadTime = (entry as any).responseEnd - (entry as any).responseStart;
              console.log(`Image ${img.alt || 'untitled'} loaded in ${loadTime.toFixed(2)}ms`);
            }
          });
        });

        observer.observe({ entryTypes: ['resource'] });
      };

      images.forEach(img => trackImagePerformance(img as HTMLImageElement));
    }
  });
</script>