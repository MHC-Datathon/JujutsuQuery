---
/**
 * Keyboard Navigation Enhancement - Comprehensive keyboard navigation for all interactive components
 * Implements WCAG 2.1 AA keyboard navigation patterns
 */

export interface Props {
  enableFocusTrapping?: boolean;
  enableVirtualCursor?: boolean;
  enableAriaLive?: boolean;
  className?: string;
}

const {
  enableFocusTrapping = true,
  enableVirtualCursor = true,
  enableAriaLive = true,
  className = ""
} = Astro.props;
---

<div class={`keyboard-navigation ${className}`} data-keyboard-nav="true">
  <!-- Skip Link -->
  <a href="#main-content" class="skip-link">Skip to main content</a>

  <!-- Focus Indicator -->
  <div id="focus-indicator" class="focus-indicator" aria-hidden="true"></div>

  <!-- ARIA Live Regions -->
  {enableAriaLive && (
    <Fragment>
      <div id="aria-live-polite" aria-live="polite" aria-atomic="false" class="sr-only"></div>
      <div id="aria-live-assertive" aria-live="assertive" aria-atomic="true" class="sr-only"></div>
    </Fragment>
  )}

  <!-- Keyboard Help Modal -->
  <div id="keyboard-help-modal" class="keyboard-help-modal" role="dialog" aria-labelledby="keyboard-help-title" aria-modal="true" hidden>
    <div class="modal-backdrop" data-close-modal="true"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="keyboard-help-title">Keyboard Navigation Help</h2>
        <button type="button" class="modal-close" data-close-modal="true" aria-label="Close keyboard help">
          <span aria-hidden="true">×</span>
        </button>
      </div>

      <div class="modal-body">
        <div class="help-section">
          <h3>General Navigation</h3>
          <dl class="keyboard-shortcuts">
            <dt><kbd>Tab</kbd></dt>
            <dd>Move to next interactive element</dd>

            <dt><kbd>Shift + Tab</kbd></dt>
            <dd>Move to previous interactive element</dd>

            <dt><kbd>Enter</kbd> or <kbd>Space</kbd></dt>
            <dd>Activate buttons and links</dd>

            <dt><kbd>Escape</kbd></dt>
            <dd>Close modals and dropdowns</dd>

            <dt><kbd>F1</kbd> or <kbd>?</kbd></dt>
            <dd>Show this keyboard help</dd>
          </dl>
        </div>

        <div class="help-section">
          <h3>Data Visualizations</h3>
          <dl class="keyboard-shortcuts">
            <dt><kbd>Arrow Keys</kbd></dt>
            <dd>Navigate through chart data points</dd>

            <dt><kbd>Home</kbd> / <kbd>End</kbd></dt>
            <dd>Jump to first/last data point</dd>

            <dt><kbd>Page Up</kbd> / <kbd>Page Down</kbd></dt>
            <dd>Navigate by groups or sections</dd>

            <dt><kbd>Enter</kbd></dt>
            <dd>Select/highlight data point</dd>

            <dt><kbd>Space</kbd></dt>
            <dd>Toggle data point selection</dd>
          </dl>
        </div>

        <div class="help-section">
          <h3>Forms and Controls</h3>
          <dl class="keyboard-shortcuts">
            <dt><kbd>Arrow Keys</kbd></dt>
            <dd>Navigate radio buttons and select options</dd>

            <dt><kbd>Space</kbd></dt>
            <dd>Toggle checkboxes</dd>

            <dt><kbd>Alt + ↓</kbd></dt>
            <dd>Open dropdown/combobox</dd>

            <dt><kbd>Escape</kbd></dt>
            <dd>Close dropdown without selection</dd>
          </dl>
        </div>

        <div class="help-section">
          <h3>Tables and Data</h3>
          <dl class="keyboard-shortcuts">
            <dt><kbd>Arrow Keys</kbd></dt>
            <dd>Navigate table cells</dd>

            <dt><kbd>Ctrl + Arrow</kbd></dt>
            <dd>Jump to edge of data region</dd>

            <dt><kbd>Ctrl + Home</kbd> / <kbd>Ctrl + End</kbd></dt>
            <dd>Jump to first/last cell</dd>

            <dt><kbd>Enter</kbd></dt>
            <dd>Sort column or activate cell action</dd>
          </dl>
        </div>
      </div>
    </div>
  </div>

  <!-- Virtual Cursor Display (for screen reader simulation) -->
  {enableVirtualCursor && (
    <div id="virtual-cursor" class="virtual-cursor" aria-hidden="true" hidden>
      <div class="cursor-content">
        <div class="cursor-type"></div>
        <div class="cursor-text"></div>
      </div>
    </div>
  )}
</div>

<style>
  .keyboard-navigation {
    position: relative;
  }

  /* Skip Link */
  .skip-link {
    position: absolute;
    top: -100px;
    left: 10px;
    z-index: 9999;
    background: #000;
    color: #fff;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    text-decoration: none;
    font-weight: 600;
    transition: top 0.2s;
  }

  .skip-link:focus {
    top: 10px;
  }

  /* Screen Reader Only */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Enhanced Focus Indicator */
  .focus-indicator {
    position: fixed;
    pointer-events: none;
    z-index: 9998;
    border: 3px solid #2563eb;
    border-radius: 4px;
    background: rgba(37, 99, 235, 0.1);
    opacity: 0;
    transition: all 0.2s ease;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5);
  }

  .focus-indicator.active {
    opacity: 1;
    transform: scale(1.05);
  }

  /* Keyboard Help Modal */
  .keyboard-help-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
  }

  .modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }

  .modal-content {
    position: relative;
    background: white;
    border-radius: 8px;
    max-width: 600px;
    max-height: 80vh;
    margin: 2rem;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    overflow: hidden;
  }

  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.5rem 2rem 1rem;
    border-bottom: 1px solid var(--color-border);
  }

  .modal-header h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--color-text-primary);
  }

  .modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0.5rem;
    margin: -0.5rem;
    border-radius: 4px;
    color: var(--color-text-secondary);
    transition: all 0.2s;
  }

  .modal-close:hover,
  .modal-close:focus {
    background: var(--color-gray-100);
    color: var(--color-text-primary);
  }

  .modal-body {
    padding: 1.5rem 2rem 2rem;
    max-height: 60vh;
    overflow-y: auto;
  }

  .help-section {
    margin-bottom: 2rem;
  }

  .help-section:last-child {
    margin-bottom: 0;
  }

  .help-section h3 {
    margin: 0 0 1rem;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-text-primary);
  }

  .keyboard-shortcuts {
    display: grid;
    gap: 0.75rem;
    margin: 0;
  }

  .keyboard-shortcuts dt {
    font-weight: 600;
    color: var(--color-text-primary);
  }

  .keyboard-shortcuts dd {
    margin: 0;
    padding-left: 1rem;
    color: var(--color-text-secondary);
    font-size: 0.95rem;
  }

  kbd {
    display: inline-block;
    padding: 0.2rem 0.4rem;
    background: var(--color-gray-100);
    border: 1px solid var(--color-border);
    border-radius: 3px;
    font-size: 0.85rem;
    font-family: monospace;
    color: var(--color-text-primary);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }

  /* Virtual Cursor */
  .virtual-cursor {
    position: fixed;
    pointer-events: none;
    z-index: 9997;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 0.5rem;
    border-radius: 4px;
    font-size: 0.9rem;
    max-width: 300px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
  }

  .cursor-type {
    font-weight: 600;
    font-size: 0.8rem;
    opacity: 0.8;
    margin-bottom: 0.25rem;
  }

  .cursor-text {
    line-height: 1.4;
  }

  /* High Contrast Mode */
  @media (prefers-contrast: high) {
    .focus-indicator {
      border-width: 4px;
      border-color: #000;
      background: rgba(255, 255, 0, 0.3);
    }

    .modal-content {
      border: 2px solid #000;
    }

    kbd {
      border-color: #000;
      background: #fff;
    }
  }

  /* Reduced Motion */
  @media (prefers-reduced-motion: reduce) {
    .focus-indicator,
    .modal-content {
      transition: none;
    }
  }

  /* Mobile Adaptations */
  @media (max-width: 768px) {
    .modal-content {
      margin: 1rem;
      max-height: 90vh;
    }

    .modal-header,
    .modal-body {
      padding: 1rem;
    }

    .keyboard-shortcuts {
      gap: 0.5rem;
    }

    .keyboard-shortcuts dd {
      padding-left: 0.5rem;
    }
  }
</style>

<script>
  interface FocusableElement extends HTMLElement {
    tabIndex: number;
    focus(): void;
    blur(): void;
  }

  interface NavigationTarget {
    element: HTMLElement;
    type: 'button' | 'link' | 'input' | 'select' | 'textarea' | 'chart' | 'table' | 'modal';
    role?: string;
    description?: string;
  }

  class KeyboardNavigationManager {
    private focusIndicator: HTMLElement | null = null;
    private ariaLivePolite: HTMLElement | null = null;
    private ariaLiveAssertive: HTMLElement | null = null;
    private virtualCursor: HTMLElement | null = null;
    private keyboardHelpModal: HTMLElement | null = null;

    private currentFocusTarget: HTMLElement | null = null;
    private focusHistory: HTMLElement[] = [];
    private navigationTargets: NavigationTarget[] = [];

    private keyHandlers: Map<string, (event: KeyboardEvent) => void> = new Map();
    private isModalOpen: boolean = false;
    private focusTrappingEnabled: boolean = true;

    constructor() {
      this.init();
    }

    private init(): void {
      this.setupElements();
      this.setupKeyHandlers();
      this.setupEventListeners();
      this.scanForNavigationTargets();

      // Initial focus management
      this.manageFocus();
    }

    private setupElements(): void {
      this.focusIndicator = document.getElementById('focus-indicator');
      this.ariaLivePolite = document.getElementById('aria-live-polite');
      this.ariaLiveAssertive = document.getElementById('aria-live-assertive');
      this.virtualCursor = document.getElementById('virtual-cursor');
      this.keyboardHelpModal = document.getElementById('keyboard-help-modal');
    }

    private setupKeyHandlers(): void {
      // Global keyboard shortcuts
      this.keyHandlers.set('F1', this.showKeyboardHelp.bind(this));
      this.keyHandlers.set('?', this.showKeyboardHelp.bind(this));
      this.keyHandlers.set('Escape', this.handleEscape.bind(this));
      this.keyHandlers.set('Tab', this.handleTab.bind(this));
      this.keyHandlers.set('Shift+Tab', this.handleTab.bind(this));

      // Navigation shortcuts
      this.keyHandlers.set('ArrowUp', this.handleArrowNavigation.bind(this));
      this.keyHandlers.set('ArrowDown', this.handleArrowNavigation.bind(this));
      this.keyHandlers.set('ArrowLeft', this.handleArrowNavigation.bind(this));
      this.keyHandlers.set('ArrowRight', this.handleArrowNavigation.bind(this));
      this.keyHandlers.set('Home', this.handleHomeEnd.bind(this));
      this.keyHandlers.set('End', this.handleHomeEnd.bind(this));
      this.keyHandlers.set('PageUp', this.handlePageNavigation.bind(this));
      this.keyHandlers.set('PageDown', this.handlePageNavigation.bind(this));

      // Action shortcuts
      this.keyHandlers.set('Enter', this.handleEnter.bind(this));
      this.keyHandlers.set(' ', this.handleSpace.bind(this));
    }

    private setupEventListeners(): void {
      // Global keyboard listener
      document.addEventListener('keydown', this.handleKeyDown.bind(this));

      // Focus management
      document.addEventListener('focusin', this.handleFocusIn.bind(this));
      document.addEventListener('focusout', this.handleFocusOut.bind(this));

      // Modal event listeners
      if (this.keyboardHelpModal) {
        this.keyboardHelpModal.addEventListener('click', this.handleModalClick.bind(this));
      }

      // Mutation observer to detect dynamic content
      const observer = new MutationObserver(this.handleDOMChanges.bind(this));
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['tabindex', 'aria-hidden', 'hidden']
      });
    }

    private scanForNavigationTargets(): void {
      this.navigationTargets = [];

      // Find all focusable elements
      const focusableSelector = [
        'a[href]',
        'button:not([disabled])',
        'input:not([disabled])',
        'select:not([disabled])',
        'textarea:not([disabled])',
        '[tabindex]:not([tabindex="-1"])',
        '[role="button"]:not([disabled])',
        '[role="link"]:not([disabled])',
        '[role="menuitem"]:not([disabled])',
        '[role="tab"]:not([disabled])',
        '[data-keyboard-target]'
      ].join(', ');

      const elements = document.querySelectorAll(focusableSelector) as NodeListOf<HTMLElement>;

      elements.forEach(element => {
        if (this.isElementVisible(element)) {
          this.navigationTargets.push(this.categorizeElement(element));
        }
      });
    }

    private categorizeElement(element: HTMLElement): NavigationTarget {
      const tagName = element.tagName.toLowerCase();
      const role = element.getAttribute('role');
      const type = element.getAttribute('type');

      let category: NavigationTarget['type'] = 'button';
      let description = '';

      if (tagName === 'a') {
        category = 'link';
        description = element.textContent || element.getAttribute('aria-label') || '';
      } else if (tagName === 'button' || role === 'button') {
        category = 'button';
        description = element.textContent || element.getAttribute('aria-label') || '';
      } else if (tagName === 'input') {
        category = 'input';
        description = element.getAttribute('placeholder') || element.getAttribute('aria-label') || '';
      } else if (tagName === 'select') {
        category = 'select';
        description = element.getAttribute('aria-label') || 'Select dropdown';
      } else if (tagName === 'textarea') {
        category = 'textarea';
        description = element.getAttribute('placeholder') || element.getAttribute('aria-label') || '';
      } else if (element.closest('[role="grid"], table')) {
        category = 'table';
        description = 'Table navigation';
      } else if (element.closest('[data-chart]')) {
        category = 'chart';
        description = 'Data visualization';
      } else if (role === 'dialog' || element.closest('[role="dialog"]')) {
        category = 'modal';
        description = 'Modal dialog';
      }

      return {
        element,
        type: category,
        role,
        description: description.trim()
      };
    }

    private isElementVisible(element: HTMLElement): boolean {
      if (element.hidden || element.getAttribute('aria-hidden') === 'true') {
        return false;
      }

      const style = getComputedStyle(element);
      if (style.display === 'none' || style.visibility === 'hidden') {
        return false;
      }

      return true;
    }

    private handleKeyDown(event: KeyboardEvent): void {
      const key = this.getKeySignature(event);
      const handler = this.keyHandlers.get(key);

      if (handler) {
        // Check if we should handle this event
        if (this.shouldHandleKeyEvent(event)) {
          event.preventDefault();
          handler(event);
        }
      }
    }

    private getKeySignature(event: KeyboardEvent): string {
      const parts: string[] = [];

      if (event.ctrlKey) parts.push('Ctrl');
      if (event.altKey) parts.push('Alt');
      if (event.shiftKey) parts.push('Shift');
      if (event.metaKey) parts.push('Meta');

      parts.push(event.key);

      return parts.join('+');
    }

    private shouldHandleKeyEvent(event: KeyboardEvent): boolean {
      // Don't handle events in form inputs unless it's a navigation key
      const target = event.target as HTMLElement;
      const isFormElement = target.matches('input, textarea, select, [contenteditable]');
      const isNavigationKey = ['Tab', 'Escape', 'F1'].includes(event.key);

      if (isFormElement && !isNavigationKey) {
        return false;
      }

      return true;
    }

    private handleTab(event: KeyboardEvent): void {
      // Enhanced tab navigation with focus trapping
      if (this.isModalOpen && this.focusTrappingEnabled) {
        this.handleModalTabNavigation(event);
      }
    }

    private handleModalTabNavigation(event: KeyboardEvent): void {
      if (!this.keyboardHelpModal) return;

      const focusableElements = this.keyboardHelpModal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      ) as NodeListOf<HTMLElement>;

      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (event.shiftKey) {
        if (document.activeElement === firstElement) {
          event.preventDefault();
          lastElement.focus();
        }
      } else {
        if (document.activeElement === lastElement) {
          event.preventDefault();
          firstElement.focus();
        }
      }
    }

    private handleArrowNavigation(event: KeyboardEvent): void {
      const target = this.currentFocusTarget;
      if (!target) return;

      // Chart navigation
      if (target.closest('[data-chart]')) {
        this.handleChartNavigation(event);
        return;
      }

      // Table navigation
      if (target.closest('table, [role="grid"]')) {
        this.handleTableNavigation(event);
        return;
      }

      // General element navigation
      this.handleGeneralNavigation(event);
    }

    private handleChartNavigation(event: KeyboardEvent): void {
      const chart = this.currentFocusTarget?.closest('[data-chart]') as HTMLElement;
      if (!chart) return;

      // Dispatch custom chart navigation event
      chart.dispatchEvent(new CustomEvent('chart-navigate', {
        detail: {
          direction: event.key.replace('Arrow', '').toLowerCase(),
          target: this.currentFocusTarget
        }
      }));

      this.announceToScreenReader(`Navigating chart ${event.key.replace('Arrow', '').toLowerCase()}`);
    }

    private handleTableNavigation(event: KeyboardEvent): void {
      const cell = this.currentFocusTarget?.closest('td, th') as HTMLElement;
      if (!cell) return;

      const table = cell.closest('table') as HTMLTableElement;
      const row = cell.parentElement as HTMLTableRowElement;
      const cellIndex = Array.from(row.children).indexOf(cell);
      const rowIndex = Array.from(table.rows).indexOf(row);

      let targetCell: HTMLElement | null = null;

      switch (event.key) {
        case 'ArrowUp':
          if (rowIndex > 0) {
            targetCell = table.rows[rowIndex - 1].children[cellIndex] as HTMLElement;
          }
          break;
        case 'ArrowDown':
          if (rowIndex < table.rows.length - 1) {
            targetCell = table.rows[rowIndex + 1].children[cellIndex] as HTMLElement;
          }
          break;
        case 'ArrowLeft':
          if (cellIndex > 0) {
            targetCell = row.children[cellIndex - 1] as HTMLElement;
          }
          break;
        case 'ArrowRight':
          if (cellIndex < row.children.length - 1) {
            targetCell = row.children[cellIndex + 1] as HTMLElement;
          }
          break;
      }

      if (targetCell) {
        targetCell.focus();
        this.announceToScreenReader(`${targetCell.textContent || 'Empty cell'}`);
      }
    }

    private handleGeneralNavigation(event: KeyboardEvent): void {
      const currentIndex = this.navigationTargets.findIndex(
        target => target.element === this.currentFocusTarget
      );

      if (currentIndex === -1) return;

      let targetIndex = currentIndex;

      switch (event.key) {
        case 'ArrowUp':
        case 'ArrowLeft':
          targetIndex = Math.max(0, currentIndex - 1);
          break;
        case 'ArrowDown':
        case 'ArrowRight':
          targetIndex = Math.min(this.navigationTargets.length - 1, currentIndex + 1);
          break;
      }

      if (targetIndex !== currentIndex) {
        const target = this.navigationTargets[targetIndex];
        target.element.focus();
        this.announceNavigationTarget(target);
      }
    }

    private handleHomeEnd(event: KeyboardEvent): void {
      if (event.key === 'Home') {
        if (this.navigationTargets.length > 0) {
          this.navigationTargets[0].element.focus();
        }
      } else if (event.key === 'End') {
        if (this.navigationTargets.length > 0) {
          this.navigationTargets[this.navigationTargets.length - 1].element.focus();
        }
      }
    }

    private handlePageNavigation(event: KeyboardEvent): void {
      const currentIndex = this.navigationTargets.findIndex(
        target => target.element === this.currentFocusTarget
      );

      if (currentIndex === -1) return;

      const pageSize = 10; // Jump by 10 elements
      let targetIndex: number;

      if (event.key === 'PageUp') {
        targetIndex = Math.max(0, currentIndex - pageSize);
      } else {
        targetIndex = Math.min(this.navigationTargets.length - 1, currentIndex + pageSize);
      }

      const target = this.navigationTargets[targetIndex];
      target.element.focus();
      this.announceNavigationTarget(target);
    }

    private handleEnter(event: KeyboardEvent): void {
      const target = this.currentFocusTarget;
      if (!target) return;

      // Let the default behavior handle most cases
      // Special handling for custom elements
      if (target.hasAttribute('data-keyboard-target')) {
        target.dispatchEvent(new CustomEvent('keyboard-activate', {
          detail: { key: 'Enter' }
        }));
      }
    }

    private handleSpace(event: KeyboardEvent): void {
      const target = this.currentFocusTarget;
      if (!target) return;

      // Prevent scrolling for buttons and custom elements
      if (target.matches('button, [role="button"], [data-keyboard-target]')) {
        event.preventDefault();
        target.click();
      }
    }

    private handleEscape(event: KeyboardEvent): void {
      if (this.isModalOpen) {
        this.hideKeyboardHelp();
      }

      // Close any open dropdowns or modals
      document.querySelectorAll('[aria-expanded="true"]').forEach(element => {
        element.setAttribute('aria-expanded', 'false');
      });
    }

    private showKeyboardHelp(): void {
      if (!this.keyboardHelpModal) return;

      this.isModalOpen = true;
      this.keyboardHelpModal.hidden = false;

      // Focus the close button
      const closeButton = this.keyboardHelpModal.querySelector('.modal-close') as HTMLElement;
      if (closeButton) {
        closeButton.focus();
      }

      this.announceToScreenReader('Keyboard help dialog opened');
    }

    private hideKeyboardHelp(): void {
      if (!this.keyboardHelpModal) return;

      this.isModalOpen = false;
      this.keyboardHelpModal.hidden = true;

      // Return focus to previous element
      if (this.focusHistory.length > 0) {
        const lastFocused = this.focusHistory.pop();
        if (lastFocused) {
          lastFocused.focus();
        }
      }

      this.announceToScreenReader('Keyboard help dialog closed');
    }

    private handleModalClick(event: Event): void {
      const target = event.target as HTMLElement;
      if (target.hasAttribute('data-close-modal') || target.closest('[data-close-modal]')) {
        this.hideKeyboardHelp();
      }
    }

    private handleFocusIn(event: FocusEvent): void {
      const target = event.target as HTMLElement;
      this.currentFocusTarget = target;

      // Update focus history
      this.focusHistory.push(target);
      if (this.focusHistory.length > 10) {
        this.focusHistory.shift();
      }

      // Update focus indicator
      this.updateFocusIndicator(target);

      // Update virtual cursor if enabled
      this.updateVirtualCursor(target);
    }

    private handleFocusOut(event: FocusEvent): void {
      // Hide focus indicator with a delay to avoid flickering
      setTimeout(() => {
        if (document.activeElement !== event.target) {
          this.hideFocusIndicator();
        }
      }, 100);
    }

    private updateFocusIndicator(element: HTMLElement): void {
      if (!this.focusIndicator) return;

      const rect = element.getBoundingClientRect();

      this.focusIndicator.style.left = `${rect.left - 2}px`;
      this.focusIndicator.style.top = `${rect.top - 2}px`;
      this.focusIndicator.style.width = `${rect.width + 4}px`;
      this.focusIndicator.style.height = `${rect.height + 4}px`;

      this.focusIndicator.classList.add('active');
    }

    private hideFocusIndicator(): void {
      if (!this.focusIndicator) return;
      this.focusIndicator.classList.remove('active');
    }

    private updateVirtualCursor(element: HTMLElement): void {
      if (!this.virtualCursor) return;

      const target = this.categorizeElement(element);
      const cursorType = this.virtualCursor.querySelector('.cursor-type') as HTMLElement;
      const cursorText = this.virtualCursor.querySelector('.cursor-text') as HTMLElement;

      if (cursorType && cursorText) {
        cursorType.textContent = target.type.toUpperCase();
        cursorText.textContent = target.description || element.textContent || 'Interactive element';

        const rect = element.getBoundingClientRect();
        this.virtualCursor.style.left = `${rect.right + 10}px`;
        this.virtualCursor.style.top = `${rect.top}px`;
        this.virtualCursor.hidden = false;

        // Auto-hide after 3 seconds
        setTimeout(() => {
          if (this.virtualCursor) {
            this.virtualCursor.hidden = true;
          }
        }, 3000);
      }
    }

    private announceToScreenReader(message: string, priority: 'polite' | 'assertive' = 'polite'): void {
      const liveRegion = priority === 'assertive' ? this.ariaLiveAssertive : this.ariaLivePolite;
      if (!liveRegion) return;

      liveRegion.textContent = message;

      // Clear the message after a delay
      setTimeout(() => {
        if (liveRegion) {
          liveRegion.textContent = '';
        }
      }, 1000);
    }

    private announceNavigationTarget(target: NavigationTarget): void {
      const message = target.description
        ? `${target.type}: ${target.description}`
        : target.type;

      this.announceToScreenReader(message);
    }

    private handleDOMChanges(mutations: MutationRecord[]): void {
      let shouldRescan = false;

      mutations.forEach(mutation => {
        if (mutation.type === 'childList') {
          shouldRescan = true;
        } else if (mutation.type === 'attributes') {
          const target = mutation.target as HTMLElement;
          if (target.matches('[tabindex], [aria-hidden], [hidden]')) {
            shouldRescan = true;
          }
        }
      });

      if (shouldRescan) {
        // Debounce rescanning
        clearTimeout(this.rescanTimeout);
        this.rescanTimeout = setTimeout(() => {
          this.scanForNavigationTargets();
        }, 250);
      }
    }

    private rescanTimeout?: number;

    private manageFocus(): void {
      // Set up initial focus management
      document.addEventListener('DOMContentLoaded', () => {
        // Focus the first interactive element if no element has focus
        if (!document.activeElement || document.activeElement === document.body) {
          const firstFocusable = document.querySelector('[tabindex]:not([tabindex="-1"]), button, a[href], input, select, textarea') as HTMLElement;
          if (firstFocusable) {
            firstFocusable.focus();
          }
        }
      });
    }

    // Public API for external components
    public registerNavigationTarget(element: HTMLElement, type: NavigationTarget['type'], description?: string): void {
      this.navigationTargets.push({
        element,
        type,
        description
      });
    }

    public announce(message: string, priority: 'polite' | 'assertive' = 'polite'): void {
      this.announceToScreenReader(message, priority);
    }

    public focusElement(selector: string): void {
      const element = document.querySelector(selector) as HTMLElement;
      if (element) {
        element.focus();
      }
    }
  }

  // Initialize keyboard navigation when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const keyboardNav = new KeyboardNavigationManager();

    // Expose to global scope for external components
    (window as any).keyboardNavigation = keyboardNav;
  });
</script>